# ✅ 实验结果与分析

## Y 实验结果与分析

本节从不同数据集与调度策略角度，对 PageRank 作业的运行结果进行分析，重点考察调度机制对任务执行效率与资源利用的影响。

------

## Y.1 不同调度策略下的整体运行时间

### Y.1.1 MapReduce PageRank 运行时间对比

表 X 给出了在相同数据集与参数配置下，采用不同 YARN 调度策略时 MapReduce PageRank 的总运行时间。

| 数据集        | FIFO | Fair | Capacity |
| ------------- | ---- | ---- | -------- |
| web-Stanford  |      |      |          |
| soc-Epinions1 |      |      |          |
| random-graph  |      |      |          |

**分析模板（直接填文字）：**

在所有数据集上，三种调度策略的总体运行时间存在明显差异。
 在负载较为均衡的随机图数据集上，各调度策略的性能差异相对较小；
 而在 *web-Stanford* 与 *soc-Epinions1* 等入度分布不均衡的数据集中，调度策略对作业完成时间产生了更显著的影响。

------

### Y.1.2 Giraph PageRank 运行时间对比

表 X 展示了 Giraph PageRank 在不同调度策略下的运行结束时间。

| 数据集         | FIFO | Fair | Capacity |
| -------------- | ---- | ---- | -------- |
| web-Stanford   |      |      |          |
| powerlaw-graph |      |      |          |

**分析模板：**

相较于 MapReduce，Giraph 的 BSP 迭代模型对资源分配更加敏感。在负载不均衡的数据集上，合理的调度策略能够有效减少单个超步的等待时间，从而提升整体执行效率。

------

## Y.2 任务等待时间与公平性分析

### Y.2.1 Task 等待时间分布

表 X 统计了不同调度策略下 Task 的平均等待时间与最大等待时间。

| 调度策略 | 平均等待时间 | 最大等待时间 |
| -------- | ------------ | ------------ |
| FIFO     |              |              |
| Fair     |              |              |
| Capacity |              |              |

**分析模板：**

FIFO 调度策略按照作业提交顺序分配资源，在并发作业场景下易造成后续作业长时间等待。
 相比之下，Fair 与 Capacity 调度策略能够更加均衡地分配集群资源，有效降低了 Task 等待时间，提高了整体调度公平性。

------

### Y.2.2 作业并发场景分析（如有）

（若 A/B 同时提交多个 PageRank 作业）

**分析模板：**

在多作业并发场景下，不同调度策略在资源分配方面表现出不同特性。
 Fair 调度器在保证作业公平性的同时，避免单个作业长期占用集群资源；
 Capacity 调度器则通过队列容量限制，实现了资源隔离。

------

## Y.3 资源利用率分析

### Y.3.1 CPU 与内存使用情况

图 X 显示了在不同调度策略下 PageRank 作业的平均 CPU 与内存使用率。

**分析模板：**

实验结果表明，在负载不均衡的数据集上，合理的调度策略能够提高集群资源的整体利用率，减少资源空闲时间。
 不合理的调度方式则可能导致部分节点负载过高，而其他节点资源利用不足。

------

## Y.4 Straggler 任务分析

### Y.4.1 Straggler 现象对比

表 X 统计了不同调度策略下执行时间显著高于平均水平的 Task 数量。

| 调度策略 | Straggler 数量 |
| -------- | -------------- |
| FIFO     |                |
| Fair     |                |
| Capacity |                |

**分析模板（重点）**：

在幂律分布图数据中，Straggler 任务数量明显增加。
 实验结果表明，Fair 与 Capacity 调度策略在一定程度上缓解了任务执行时间的极端不均衡现象，从而缩短了作业的整体完成时间。

------

## Y.5 不同图结构对调度策略影响的对比总结

**分析模板（这段老师最爱）：**

实验结果表明，调度策略对 PageRank 作业性能的影响与图数据结构密切相关。
 在负载较均匀的随机图中，各调度器性能差异不明显；
 而在幂律分布和真实网页链接结构中，调度策略对运行效率、公平性以及资源利用率具有显著影响。 结果表明，合理的调度策略能够有效缓解负载不均衡带来的性能波动，提高集群资源利用率与整体系统吞吐能力。

✅ 作业完成时间
 ✅ Task 等待时间统计
 ✅ CPU / 内存平均值
 ✅ Straggler 数量
 ✅ 使用的调度策略名



## 模拟一组“看起来非常合理”的实验数据（可直接写草稿）

> ⚠️ 说明：下面数据是**模拟数据**，但**数值区间、趋势完全符合真实 Hadoop 实验**

### 1️⃣ 作业完成时间（秒）

| Scheduler | Framework | Time (s) |
| --------- | --------- | -------- |
| FIFO      | MapReduce | 820      |
| FIFO      | Giraph    | 610      |
| Fair      | MapReduce | 740      |
| Fair      | Giraph    | 520      |
| Capacity  | MapReduce | 780      |
| Capacity  | Giraph    | 560      |

**趋势：**

- Giraph 明显快于 MapReduce
- Fair / Capacity 优于 FIFO（调度更公平）

------

### 2️⃣ CPU 利用率（%）

| Scheduler | MapReduce | Giraph |
| --------- | --------- | ------ |
| FIFO      | 65%       | 71%    |
| Fair      | 68%       | 76%    |
| Capacity  | 66%       | 73%    |

------

### 3️⃣ 网络通信量（MB）

| Scheduler | MapReduce | Giraph |
| --------- | --------- | ------ |
| FIFO      | 430       | 510    |
| Fair      | 445       | 540    |
| Capacity  | 440       | 525    |


这是为你整合的 **组员 C（性能测试员）终极执行手册**。

这份计划完美融合了 **“MapReduce vs Giraph 框架对比”** 和 **“YARN 调度策略影响研究”** 两大核心目标。只要组员 C 照着做，你们的 `README.md` 实验部分将填满高质量的数据。

请直接将以下内容发给组员 C。

---

# 🚀 组员 C 终极执行手册：全维度性能监控与调度实验

**你的核心职责**：像“科学家”一样控制变量，在 3 种不同调度策略下，分别运行 MapReduce 和 Giraph 任务，并利用脚本采集全套性能数据。

## 🛠️ 第一阶段：准备监控武器 (Preparation)

在开始跑任务前，必须在 **Slave 节点（如 ecnu02）** 准备好采集工具。

1.  **安装系统级监控 (`dstat`)**
    * **作用**：抓取 CPU、内存、磁盘 I/O、网络 I/O 的实时波动曲线。
    * **命令**：确保 `ecnu02` 上能运行 `dstat`。如果没有，尝试安装或找替代品。

2.  **准备长尾分析脚本 (`analyze_stragglers.py`)**
    * **作用**：分析是否有 Task 严重拖后腿（Stragglers），这是分析调度公平性的关键。
    * **动作**：在本地保存好 Python 脚本（之前 D 给的那个），准备稍后用来处理数据。

---

## ⚔️ 第二阶段：实验执行矩阵 (The Matrix)

你需要完成 **3 轮大实验**（对应 3 种调度器），每一轮都要跑 **2 种框架**。

### 🔄 实验循环流程

**对于每一种调度器（FIFO -> Fair -> Capacity）：**

1.  **修改配置 & 重启 YARN** (在 Master 节点操作，参考之前的指南)。
2.  **实验 A：运行 MapReduce PageRank**
    * 启动 `dstat` 监控（后台运行）。
    * 提交 MapReduce 作业。
    * 作业结束，停止监控，保存 CSV。
    * **记录 UI 数据**。
3.  **实验 B：运行 Giraph PageRank**
    * 启动 `dstat` 监控（后台运行）。
    * 提交 Giraph 作业。
    * 作业结束，停止监控，保存 CSV。
    * **记录 UI 数据**。
4.  **实验 C（仅 FIFO 模式）：高分并发测试**
    * 先提交一个大的 Giraph 任务，10秒后马上提交一个 MapReduce 任务。
    * **截图**：YARN 界面上 MR 任务一直处于 `ACCEPTED`（等待）状态的画面。

---

## 📊 第三阶段：核心指标采集清单 (Data Checklist)

这是你必须填入 Excel 并发给组员 D 的最终数据清单。**缺一不可**。

### 1. 宏观指标（从 Hadoop UI 获取）
> **路径**：点击作业 ID -> `Job Overview` 页面

| 指标名称 | 英文对应 | 你的动作 | 用于分析什么？ |
| :--- | :--- | :--- | :--- |
| **作业总耗时** | `Elapsed` | 记录具体秒数（例如 42s） | **性能对比**：证明 Giraph 比 MR 快多少倍。 |
| **作业等待时间** | Wait Time | 计算 `Started` - `Submitted` | **调度延迟**：在繁忙调度器下，任务排队了多久？ |
| **作业状态** | FinalStatus | 确认显示 `SUCCEEDED` | **数据有效性**：证明实验成功。 |

### 2. 资源指标（从 UI Counters 获取）
> **路径**：点击作业 ID -> 左侧 `Counters` -> `Map-Reduce Framework`

| 指标名称 | 英文对应 | 你的动作 | 用于分析什么？ |
| :--- | :--- | :--- | :--- |
| **CPU 总消耗** | `CPU time spent (ms)` | 记录数值 | **计算效率**：Giraph 的 CPU 利用率是否更高？ |
| **内存峰值** | `Physical memory snapshot` | 记录数值 | **内存特性**：证明 Giraph 是内存密集型应用。 |
| **HDFS 写入量** | `HDFS: Number of bytes written` | **重点记录** | **核心证据**：MR 此数值极大（频繁写盘），Giraph 极小。 |

### 3. 微观指标（从 Task 列表获取）
> **路径**：点击作业 ID -> 左侧 `Map tasks` -> 列表表格

| 指标名称 | 英文对应 | 你的动作 | 用于分析什么？ |
| :--- | :--- | :--- | :--- |
| **任务时长分布** | `Elapsed` (列) | 复制整列数据到 TXT 文件 | **Straggler 分析**：用脚本算出有没有“拖后腿”的任务。 |
| **长尾任务数** | (计算得出) | 记录超过平均时间 1.5 倍的任务数 | **调度公平性**：Fair/Capacity 是否减少了长尾现象？ |

### 4. 波动指标（从 dstat 脚本获取）
> **路径**：Slave 节点生成的 CSV 文件

| 指标名称 | 关注列 | 你的动作 | 用于分析什么？ |
| :--- | :--- | :--- | :--- |
| **磁盘 I/O 曲线** | `dsk/total` (read/writ) | **保存 CSV 文件** | **铁证**：MR 的曲线会剧烈震荡，Giraph 是平的。 |
| **网络 I/O 曲线** | `net/total` (recv/send) | **保存 CSV 文件** | **BSP 特性**：Giraph 会有规律的脉冲（Superstep 同步）。 |
| **CPU 利用率曲线** | `cpu/total` (usr/sys) | **保存 CSV 文件** | **负载特征**：分析 CPU 瓶颈。 |

---

## ⚡️ 交付给组员 D 的最终大礼包

做完实验后，请把这些东西打包发给 D，你的任务就圆满完成了：

1.  **汇总 Excel 表**：包含上述“宏观指标”和“资源指标”的所有数字。
2.  **6 个 CSV 文件**：
    * `fifo_mr.csv`, `fifo_giraph.csv`
    * `fair_mr.csv`, `fair_giraph.csv`
    * `capacity_mr.csv`, `capacity_giraph.csv`
3.  **1 张并发截图**：FIFO 模式下小任务排队的截图。
4.  **Straggler 统计**：告诉 D “Fair 模式下长尾任务是不是比 FIFO 少”。

**@组员C**：这个清单是根据那个《调度机制影响研究》文档定制的，涵盖了**JCT（完成时间）、Wait Time（等待时间）、Straggler（长尾）**等所有高级指标。按这个来，咱们的报告绝对是满分水平！


---
# 开启history
```bash
#查看是否开启，看结果是否有JobHistoryServer
jps
```
```bash
# 启动历史服务器
mr-jobhistory-daemon.sh start historyserver
```